{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;;AAA8D;AACjB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA,sBAAsB,uEAAc;AACpC,gBAAgB,sDAAQ;AACxB,gBAAgB,sDAAQ;AACxB,gBAAgB,sDAAQ;AACxB,gBAAgB,sDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AC1Bc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAoC,GAAG;AACzD;AACA,8BAA8B,GAAG,yCAAyC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnEmC;AACpB;AACf,IAAI,kDAAQ;AACZ;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACNA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC0C;AACsB;AAC/B;AACJ;AACN;AACvB,sBAAsB,8CAAS;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC;AACA;AACA;AACA,wBAAwB,kEAAoB;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA,4DAA4D,iEAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAmB;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0CAA0C,kEAAoB;AAC9D;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,kEAAoB;AACpD,8BAA8B,iEAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa,GAAG,sBAAsB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAS;AAC9B;AACA;AACA;AACA,IAAI,0DAAQ;AACZ;AACA;AACA,IAAI,0DAAQ;AACZ;AACA;AACA,IAAI,0DAAQ;AACZ;;;;;;;;;;;;;;;AC9NO;AACP;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCdA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WC5BA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA;WACA;;;;;WCJA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;;;;UEhDA;UACA;UACA;UACA;UACA","sources":["webpack://asg/./src/frontend/App.ts","webpack://asg/./src/frontend/Timer.ts","webpack://asg/./src/frontend/Toast.ts","webpack://asg/./src/frontend/controllers/GameController.ts","webpack://asg/./src/frontend/models/GameItem.ts","webpack://asg/webpack/bootstrap","webpack://asg/webpack/runtime/chunk loaded","webpack://asg/webpack/runtime/compat get default export","webpack://asg/webpack/runtime/define property getters","webpack://asg/webpack/runtime/global","webpack://asg/webpack/runtime/hasOwnProperty shorthand","webpack://asg/webpack/runtime/node module decorator","webpack://asg/webpack/runtime/jsonp chunk loading","webpack://asg/webpack/before-startup","webpack://asg/webpack/startup","webpack://asg/webpack/after-startup"],"sourcesContent":["import { GameController } from \"./controllers/GameController\";\nimport { GameItem } from \"./models/GameItem\";\nconst playerName = localStorage.getItem(\"player_name\");\nif (!playerName) {\n    window.location = \"./\";\n}\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n    let namePlayer = document.querySelector(\"#namePlayer\");\n    namePlayer.textContent = `Xin chào ${playerName}`;\n    const rootElement = document.querySelector(\"#app\");\n    var gameApp = null;\n    if (rootElement) {\n        gameApp = new GameController([\n            new GameItem(1, \"\", \"img1.png\"),\n            new GameItem(2, \"\", \"img2.png\"),\n            new GameItem(3, \"\", \"img3.png\"),\n            new GameItem(4, \"\", \"img4.png\"),\n            // new GameItem(5, \"\", \"img5.png\"),\n            // new GameItem(6, \"\", \"img6.png\"),\n            // new GameItem(7, \"\", \"img7.png\"),\n            // new GameItem(8, \"\", \"img8.png\"),\n            //   new GameItem(9, \"\", \"9.png\"),\n            //   new GameItem(10, \"\", \"10.png\"),\n        ], rootElement);\n        gameApp === null || gameApp === void 0 ? void 0 : gameApp.renderGameBoard();\n    }\n});\n","export default class Stopwatch {\n    constructor(elementId) {\n        this.elementId = elementId;\n        this.startTime = 0;\n        this.isRunning = false;\n        this.elapsedTimeInMilliseconds = 0;\n    }\n    start() {\n        if (!this.isRunning) {\n            this.startTime = Date.now();\n            this.intervalId = window.setInterval(() => {\n                this.updateElapsedTime();\n                this.render();\n                return this.elapsedTimeInMilliseconds;\n            }, 10);\n            this.isRunning = true;\n        }\n        return this.elapsedTimeInMilliseconds;\n    }\n    stop() {\n        if (this.isRunning) {\n            clearInterval(this.intervalId);\n            this.intervalId = undefined;\n            this.isRunning = false;\n        }\n        return this.elapsedTimeInMilliseconds;\n    }\n    reset() {\n        if (this.isRunning) {\n            clearInterval(this.intervalId);\n            this.intervalId = undefined;\n            this.isRunning = false;\n        }\n        this.startTime = 0;\n        this.elapsedTimeInMilliseconds = 0;\n        this.render();\n    }\n    getElapsedTime() {\n        return this.elapsedTimeInMilliseconds;\n    }\n    updateElapsedTime() {\n        const currentTime = Date.now();\n        this.elapsedTimeInMilliseconds =\n            this.elapsedTimeInMilliseconds + (currentTime - this.startTime);\n        this.startTime = currentTime;\n    }\n    render() {\n        const stopwatchElement = document.getElementById(this.elementId);\n        if (stopwatchElement) {\n            stopwatchElement.innerHTML = this.formatTime(this.elapsedTimeInMilliseconds);\n        }\n    }\n    formatTime(milliseconds) {\n        const minutes = Math.floor(milliseconds / 60000);\n        const seconds = Math.floor((milliseconds % 60000) / 1000);\n        const centiseconds = Math.floor((milliseconds % 1000) / 10);\n        return `${minutes.toString().padStart(2, \"0\")}:${seconds\n            .toString()\n            .padStart(2, \"0\")}.${centiseconds.toString().padStart(2, \"0\")}`;\n    }\n}\n// const stopwatch = new Stopwatch(\"stopwatch\");\n// Bắt đầu đồng hồ bằng cách gọi hàm start()\n// stopwatch.start();\n// Dừng đồng hồ bằng cách gọi hàm stop()\n// stopwatch.stop();\n// Reset đồng hồ bằng cách gọi hàm reset()\n// stopwatch.reset();\n","import Toastify from \"toastify-js\";\nexport default function toast(message, color) {\n    Toastify({\n        text: message,\n        backgroundColor: color,\n    }).showToast();\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport autobind from \"autobind-decorator\";\nimport { GameItem, GameItemStatus } from \"./../models/GameItem\";\nimport Stopwatch from \"../Timer\";\nimport toast from \"../Toast\";\nimport _ from \"lodash\";\nconst stopwatch = new Stopwatch(\"stopwatch\");\nlet totalNumberMatched = document.querySelector(\"#totalMatched\");\nlet renderTimer = document.querySelector(\"#stopwatch\");\nlet totalMatched = 0;\nlet startTimer = 0;\nlet overTimer = 120000;\nexport class GameController {\n    constructor(items, element) {\n        this.element = element;\n        this.items = [];\n        this.initGame(items);\n    }\n    initGame(initData) {\n        for (const item of initData) {\n            this.items.push(item);\n            this.items.push(new GameItem(item.id, item.divId, item.image));\n        }\n        let id = 1;\n        this.items.forEach((it) => {\n            it.status = GameItemStatus.Close;\n            it.divId = \"d\" + id;\n            id++;\n        });\n    }\n    reinitGame() {\n        this.items.forEach((item) => {\n            item.imageElement = null;\n            item.status = GameItemStatus.Close;\n            item.isMatched = false;\n        });\n        this.shuffle();\n    }\n    isWinGame() {\n        return (this.items.filter((item) => item.status === GameItemStatus.Open)\n            .length === this.items.length);\n    }\n    renderHTML(rootElement, item) {\n        // <div class=\"col-2 gameItem m-2 p1 text-center\">\n        //     <img src=\"\" alt=\"\" class=\"img-fluid\">\n        // </div>\n        const divItem = document.createElement(\"div\");\n        divItem.className = \"gameItem text-center\";\n        divItem.id = item.divId;\n        divItem.addEventListener(\"click\", this.processGameItemClicked);\n        const imgItem = document.createElement(\"img\");\n        imgItem.src = `images/${item.image}`;\n        imgItem.className = \"img-fluid invisible\";\n        item.imageElement = imgItem;\n        divItem.append(imgItem);\n        rootElement.appendChild(divItem);\n        renderTimer.innerHTML = \"00:00:00\";\n    }\n    renderResetButton(rootElement) {\n        let button = rootElement.querySelector(\"div#reset\");\n        if (button) {\n            button.addEventListener(\"click\", this.processResetButtonClicked);\n        }\n    }\n    renderCloseButton(rootElement) {\n        let button = rootElement.querySelector(\"div#cancel\");\n        if (button) {\n            button.addEventListener(\"click\", this.processCloseButtonClicked);\n        }\n    }\n    renderGameBoard() {\n        this.shuffle();\n        let boardDiv = this.element.querySelector(\"#board\");\n        if (boardDiv) {\n            this.items.forEach((it) => {\n                this.renderHTML(boardDiv, it);\n            });\n        }\n        this.renderTotalMatched();\n        this.renderResetButton(this.element);\n        this.renderCloseButton(this.element);\n    }\n    isMatched(id, imgElement) {\n        let openedItem = this.items.filter((item) => {\n            if (item.status === GameItemStatus.Open && !item.isMatched) {\n                return item;\n            }\n        });\n        if (openedItem.length == 2) {\n            let checkMatchedFilter = openedItem.filter((item) => item.id == id);\n            if (checkMatchedFilter.length < 2) {\n                toast(\"Bạn chọn chưa trùng khớp\", \"red\");\n                openedItem.forEach((item) => {\n                    this.changeMatchedBackgroud(item.imageElement, false);\n                });\n                openedItem.forEach((item) => {\n                    setTimeout(() => {\n                        if (item.imageElement) {\n                            item.imageElement.className = \"img-fluid invisible\";\n                            item.status = GameItemStatus.Close;\n                            item.isMatched = false;\n                            this.changeMatchedBackgroud(item.imageElement);\n                        }\n                    }, 600);\n                });\n            }\n            else {\n                totalMatched++;\n                this.renderTotalMatched();\n                toast(\"Chúc mừng bạn đã chọn đúng\", \"green\");\n                openedItem.forEach((item) => {\n                    item.isMatched = true;\n                    if (item.imageElement) {\n                        const img = item.imageElement;\n                        const elm = item.imageElement.parentElement;\n                        elm.className = \"gameItem text-center bgrhidden ismatched\";\n                        setTimeout(() => {\n                            img.setAttribute(\"src\", \"https://cdn-icons-png.flaticon.com/512/5610/5610944.png\");\n                        }, 800);\n                    }\n                    // this.changeMatchedBackgroud(item.imageElement);\n                });\n                return true;\n            }\n        }\n        return false;\n    }\n    changeMatchedBackgroud(imgElement, isMatched = true) {\n        if (imgElement === null || imgElement === void 0 ? void 0 : imgElement.parentElement) {\n            if (isMatched) {\n                imgElement.parentElement.className = \"gameItem text-center\";\n            }\n            else {\n                imgElement.parentElement.className =\n                    \"gameItem text-center bgrhidden unmatched\";\n            }\n        }\n    }\n    processGameItemClicked(event) {\n        let element = event.target;\n        if (element.tagName == \"img\") {\n            element = element.parentElement;\n        }\n        let isStart = 0;\n        if (isStart < 1) {\n            stopwatch.start();\n            isStart++;\n        }\n        const setinterval = setInterval(() => {\n            startTimer = stopwatch.getElapsedTime();\n            if (startTimer > overTimer) {\n                clearInterval(setinterval);\n                alert(`Bạn đã thua vì thời gian chơi quá ${overTimer / 1000} giây, trò chơi sẽ được bắt đầu lại`);\n                this.restartGame();\n            }\n        }, 100);\n        for (const item of this.items) {\n            if (item.divId == (element === null || element === void 0 ? void 0 : element.id) &&\n                !item.isMatched &&\n                item.status === GameItemStatus.Close) {\n                item.status = GameItemStatus.Open;\n                let imgElement = element.querySelector(\"img\");\n                if (imgElement) {\n                    element.classList.add(\"bgrhidden\");\n                    imgElement.className = \"img-fluid visible\";\n                    this.isMatched(item.id, imgElement);\n                }\n            }\n        }\n        if (this.isWinGame()) {\n            const endTimer = stopwatch.stop();\n            const formatTimer = stopwatch.formatTime(endTimer);\n            setTimeout(() => {\n                alert(`Bạn thắng với thời gian ${formatTimer}`);\n                if (confirm(\"Bạn có muốn chơi tiếp?\")) {\n                    this.restartGame();\n                }\n            }, 900);\n        }\n    }\n    restartGame() {\n        this.reinitGame();\n        stopwatch.reset();\n        const boardElement = document.querySelector(\"#board\");\n        boardElement.innerHTML = \"\";\n        renderTimer.innerHTML = \"00:00:00\";\n        totalMatched = 0;\n        this.renderTotalMatched();\n        this.renderGameBoard();\n    }\n    renderTotalMatched() {\n        totalNumberMatched.innerHTML = `${totalMatched}/${this.items.length / 2}`;\n    }\n    CloseGame() {\n        if (confirm(\"Bạn có muốn thoát khỏi trò chơi không?\")) {\n            localStorage.clear();\n            window.location = \"./\";\n        }\n    }\n    processResetButtonClicked(event) {\n        this.restartGame();\n    }\n    processCloseButtonClicked(event) {\n        this.CloseGame();\n    }\n    shuffle() {\n        this.items = _.shuffle(this.items);\n    }\n}\n__decorate([\n    autobind\n], GameController.prototype, \"processGameItemClicked\", null);\n__decorate([\n    autobind\n], GameController.prototype, \"processResetButtonClicked\", null);\n__decorate([\n    autobind\n], GameController.prototype, \"processCloseButtonClicked\", null);\n","export var GameItemStatus;\n(function (GameItemStatus) {\n    GameItemStatus[GameItemStatus[\"Open\"] = 0] = \"Open\";\n    GameItemStatus[GameItemStatus[\"Close\"] = 1] = \"Close\";\n})(GameItemStatus || (GameItemStatus = {}));\nexport class GameItem {\n    constructor(id, divId, image, status = GameItemStatus.Close, isMatched = false, imageElement = null) {\n        this.id = id;\n        this.divId = divId;\n        this.image = image;\n        this.status = status;\n        this.isMatched = isMatched;\n        this.imageElement = imageElement;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkasg\"] = self[\"webpackChunkasg\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_autobind-decorator_lib_esm_index_js-node_modules_lodash_lodash_js-node_m-1be5c4\"], () => (__webpack_require__(\"./src/frontend/App.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}